<!DOCTYPE html>
<html>
<head includeDefault="true">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>???</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script src="js/three.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>
		<script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="container"></div>

    <script>
				//<script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/OBJLoader.js">
        var stats = initStats();
        var scene, camera, renderer, controls, light, speed, directionalLight, gui, currentTime;
				var matArrayA=[];//内墙
        var matArrayB=[];//外墙
        var step = 0;
        var group = new THREE.Group();




        // 初始化场景
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog( scene.background, 3000, 5000 );
        }
        function initGui() {
            //声明一个保存需求修改的相关数据的对象
            gui = {
                ambientLight:"#111111", //环境光源
                directionalLight:"#ffffff", //点光源
                intensity:1, //灯光强度
                visible:true, //是否可见
                castShadow:true,
                exponent:30,
                target:"plane",
                debug:false,
                time:0,
                pause:true
            };
            var datGui = new dat.GUI();
            //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
            datGui.add(gui,"time",0 ,1440).onChange(function (e) {
              time = e;
            });
            datGui.add(gui,"pause").onChange(function (e) {
              if(e){
                //var debug = new THREE.CameraHelper(directionalLight.shadow.camera);
                //debug.name = "debug";
                //scene.add(debug);
              }
              else{
                //var debug = scene.getObjectByName("debug");
                //scene.remove(debug);
              }
            });
            datGui.addColor(gui,"ambientLight").onChange(function (e) {
              ambientLight.color = new THREE.Color(e);
            });
            //makeXYZGUI(gui, directionalLight.position, 'position');
            datGui.addColor(gui,"directionalLight").onChange(function (e) {
              directionalLight.color = new THREE.Color(e);
            });
            datGui.add(gui,"intensity",0,5).onChange(function (e) {
              directionalLight.intensity = e;
            });
            datGui.add(gui,"visible").onChange(function (e) {
              directionalLight.visible = e;
            });
            datGui.add(gui,"castShadow").onChange(function (e) {
              directionalLight.castShadow = e;
            });
            datGui.add(gui,"debug").onChange(function (e) {
              if(e){
                var debug = new THREE.CameraHelper(directionalLight.shadow.camera);
                debug.name = "debug";
                scene.add(debug);
              }
              else{
                var debug = scene.getObjectByName("debug");
                scene.remove(debug);
              }
            });
          }
        // 初始化相机
        function initCamera() {
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
						//camera.shadowCameraVisible = true;
						camera.position.set(0, 800, 1500);
            camera.lookAt(new THREE.Vector3(0, 0, 0));
        }

        // 初始化灯光
        function initLight() {
            directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );//模拟远处类似太阳的光源
            var target = new THREE.Object3D();
            target.position.set(0, 0, 0);
            scene.add(target);
						directionalLight.position.set( 500, 500, 0);
						directionalLight.castShadow = true;
						directionalLight.color.setHSL( 0.1, 1, 0.95 );
						directionalLight.shadow.camera.near = 10;
						directionalLight.shadow.camera.far = 2000;
						directionalLight.shadow.camera.left = -500;
						directionalLight.shadow.camera.right = 500;
						directionalLight.shadow.camera.top = 600;
						directionalLight.shadow.camera.bottom = -600;
						directionalLight.shadowCameraVisible = true;
						directionalLight.target = target;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.mapSize.width = 1024;
            scene.add( directionalLight) ;

            var helper = new THREE.CameraHelper(directionalLight.shadow.camera);
            scene.add(helper);
            var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.1 ); //AmbientLight,影响整个场景的光源
            ambientLight.position.set(0,0,0);
            scene.add( ambientLight );

        }

        // 初始化性能插件
        function initStats() {
            var stats = new Stats();

            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.body.appendChild(stats.domElement);
            return stats;
        }

        // 初始化渲染器
        function initRenderer() {
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x4682B4,1);
						renderer.shadowMapEnabled = true;
						renderer.shadowMapSoft = true;

            document.body.appendChild(renderer.domElement);
        }

        //创建地板
        function createFloor(){
            var loader = new THREE.TextureLoader();
            loader.load("img/grass-texture.jpg",function(texture){
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set( 20, 20 );
                var floorGeometry = new THREE.BoxGeometry(1000, 1000, 1);
                var floorMaterial = new THREE.MeshPhongMaterial( { map: texture, side: THREE.DoubleSide } );
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);
								floor.receiveShadow = true;
                //floor.castShadow = true;
								floor.position.y = -0.5;
                floor.rotation.x = Math.PI / 2;
                floor.name = "地面";
                scene.add(floor);
            });
        }

				//创建墙
				function createCubeWall(width, height, depth, angle, material, x, y, z, name){
						var cubeGeometry = new THREE.BoxGeometry(width, height, depth );
						var cube = new THREE.Mesh( cubeGeometry, material );
						cube.castShadow = true;
						cube.receiveShadow = true;
						cube.position.x = x;
						cube.position.y = y;
						cube.position.z = z;
						cube.rotation.y += angle*Math.PI;  //-逆时针旋转,+顺时针
						cube.name = name;
						scene.add(cube);
					}
					function createWallMaterail(){
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //前  0xafc0ca :灰色
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //后
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xd6e4ec}));  //上  0xd6e4ec： 偏白色
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xd6e4ec}));  //下
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //左    0xafc0ca :灰色
	            matArrayA.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //右

	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //前  0xafc0ca :灰色
	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0x9cb2d1}));  //后  0x9cb2d1：淡紫
	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0xd6e4ec}));  //上  0xd6e4ec： 偏白色
	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0xd6e4ec}));  //下
	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //左   0xafc0ca :灰色
	            matArrayB.push(new THREE.MeshPhongMaterial({color: 0xafc0ca}));  //右

	        }
        // 初始化模型
        function initContent() {
            createFloor();
						createWallMaterail();
						createCubeWall(10, 50, 1000, 0, matArrayB, -500, 25, 0, "墙面");
						createCubeWall(10, 50, 1000, 0, matArrayB, 500, 25, 0, "墙面");
						createCubeWall(10, 50, 1000, 0.5, matArrayB, 0, 25, -500, "墙面");
						createCubeWall(10, 50, 1000, 0.5, matArrayB, 0, 25, 500, "墙面");
        }

        // 初始化轨迹球控件
        function initControls() {
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.dampingFactor = 0.5;
            // 视角最小距离
            controls.minDistance = 100;
            // 视角最远距离
            controls.maxDistance = 2000;
            // 最大角度
            controls.maxPolarAngle = Math.PI/2.2;
            //controls.enablePan = true;
        }

        // 更新控件
        function update() {
            stats.update();
            controls.update();
        }

        //function updateLight(){
        //  directionalLight.target.updateMatrixWorld();
        //  helper.update();
        //}
        //updateLight();
        // 初始化
        function init() {
            initScene();
            initCamera();
            initRenderer();
            initContent();
            initLight();
            initControls();
            initGui();
            document.addEventListener('resize', onWindowResize, false);
        }
        //function makeXYZGUI(gui, vector3, name, onChangeFn) {
        //  const folder = gui.addFolder(name);
        //  folder.add(vector3, 'x', -10, 10).onChange(onChangeFn);
        //  folder.add(vector3, 'y', 0, 10).onChange(onChangeFn);
        //  folder.add(vector3, 'z', -10, 10).onChange(onChangeFn);
        //  folder.open();
        //}
        function movnigSun(obj,speed){
          step += speed;
          //obj.position.x = 100;
          obj.position.x = 10 +(750*(Math.cos(step)));
          obj.position.y = 10 +(750*(Math.sin(step)));
          obj.target.updateMatrixWorld();
        }

        // 窗口变动触发的方法
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            movnigSun(directionalLight,0.02);
            renderer.render(scene, camera);
            update();
        }

        init();
        animate();
    </script>
</body>
</html>
